{"version":3,"sources":["dist/zxdom.js"],"names":["global","factory","exports","module","define","amd","zxdom","this","seekIndex","list","fn","start","reduce","found","item","index","setAttribute","el","name","oldval","val","substr","removeAttribute","updateAttributes","oldattr","newattr","Object","keys","forEach","willRemove","oldvnode","type","attributes","children","func","inst","getInstanceIndex","instances","vnode","splice","chvnode","i","childNodes","onremove","getKey","node","attr","key","morphInstance","oldel","view","assign","data","patch","replace","seekId","seekNode","sought","morphVNode","oldch","newch","parent","n","length","o","insertBefore","make","parentNode","removeChild","appendChild","patchChildren","onupdate","newvnode","newel","replaceChild","oldnode","newnode","makeNode","svg","push","makeView","document","createElementNS","createElement","chnode","oncreate","createTextNode","h","concat","filter","c","mount","container","innerHTML","update","defineProperty","value"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.zxdom = {})));\n}(this, (function (exports) { 'use strict';\n\n    /*\n    TODO add svg support back\n\n    TODO add keys & lifecycle back\n\n    TODO refactor common patterns like \"find index of thing in array\", and perhaps others, to utility functions\n\n    TODO refactor functions that will use less property-names, and also make the code more readable and descriptive what is being done.\n\n    TODO refactor tests to be more descriptive of the api and less \"incrementally built up\"\n    */\n\n\n    /* TODO: fix this so it handles boolean attrs properly (like disabled)\n        once it does, we can probably get away with not using props for any\n    */\n\n\n    function seekIndex(list, fn, start = 0) {\n        return list.reduce((found, item, index) => (index < start || found > -1 || !fn(item)) ? found : index, -1)\n    }\n\n\n    function setAttribute(el, name, oldval, val) {\n        if (name === 'key' || name === 'value' || name === 'checked' || name.substr(0,2) === 'on') {\n            el[name] = val;\n        } else if (val == null || val === false) {\n            el.removeAttribute(name);\n        } else if (oldval !== val) {\n            el.setAttribute(name, val);\n        }\n    }\n\n    function updateAttributes (el, oldattr, newattr) {\n        Object.keys(oldattr).forEach(name => {\n            if (newattr[name] == null) setAttribute(el, name);\n        });\n        Object.keys(newattr).forEach(name => {\n            setAttribute(el, name, oldattr[name], newattr[name]);\n        });\n    }\n\n    function willRemove(el, oldvnode) {\n        if (oldvnode.type) {\n            const {type, attributes, children} = oldvnode;\n            if (type.func) {\n                const inst = getInstanceIndex(type, el);\n                willRemove(el, type.instances[inst].vnode);\n                type.instances.splice(inst, 1);\n            } else {\n                children.forEach((chvnode, i) => willRemove(el.childNodes[i], chvnode));\n                attributes.onremove && attributes.onremove(el);\n            }    \n        }\n    }\n\n    function remove(el, oldvnode) {\n        willRemove(el, oldvnode);\n        el.parentNode && el.parentNode.removeChild(el);\n    }\n\n    function getKey (node) {\n        const attr = node.attributes;\n        return (attr && attr.key) ? attr.key : null \n    }\n\n\n    function morphInstance (oldel, view, attributes, children) {\n        const vnode = view.func(Object.assign({}, attributes, view.data), children);\n        const inst = getInstanceIndex(view, oldel);\n        const oldvnode = view.instances[inst].vnode;\n        const el = (getKey(oldvnode) === getKey(vnode) ? patch : replace)(oldel, oldvnode, vnode);\n        view.instances.splice(inst, 1, {el, vnode, attributes, children});\n        return el\n    }\n\n\n    /*\n\n    OPTIMIZE:\n\n    textnodes are always inserted, then the old ones removed. If they're the same string we could leave them alone\n\n    If keyed nodes move down, we will instead move *up* every subsequent nodes one step. COuld be optimized\n    by just building a list of moves, and notice that a series of up-moves of one, could be replaced by a single\n    down move (maybe?)\n\n    */\n\n    function seekId(node) {\n        return node.type ? (node.attributes.key || node.type) : node\n    }\n    function seekNode(list, node, start) {\n        const sought = seekId(node);\n        return seekIndex(list, item => (seekId(item) === sought), start)\n    }\n\n    function patchChildren(parent, oldch, newch) {\n        let n = 0;\n        while (n < oldch.length && n < newch.length) {\n            let o = seekNode(oldch, newch[n], n);\n            if (o < 0) {\n                parent.insertBefore(make(newch[n]), parent.childNodes[n]);\n                oldch.splice(n, 0, '');\n            } else {\n                if (o != n) {\n                    parent.insertBefore(parent.childNodes[o], parent.childNodes[n]);\n                    oldch.splice(n, 0, oldch.splice(o, 1)[0]);\n                }\n                patch(parent.childNodes[n], oldch[n], newch[n]);\n            }\n            n++;\n        }\n        while (n < oldch.length) {\n            remove(parent.childNodes[n], oldch[n]);\n            oldch.splice(n, 1);\n        }\n        while (n < newch.length)  parent.appendChild(make(newch[n++]));\n    }\n\n\n    function morphVNode(el, oldattr, oldch, newattr, newch) {\n        updateAttributes(el, oldattr, newattr);\n        patchChildren(el, oldch, newch);\n        newattr.onupdate && newattr.onupdate(el);\n        return el\n    }\n\n\n    function morph (el, oldvnode, {type, attributes, children}) {\n        if (type.func) return morphInstance(el, type, attributes, children)\n        else return morphVNode(el, oldvnode.attributes, oldvnode.children, attributes, children)\n    }\n\n    function replace (el, oldvnode, newvnode) {\n        willRemove(el, oldvnode);\n        const newel = make(newvnode);\n        el.parentNode && el.parentNode.replaceChild(newel, el);\n        return newel\n    }\n\n\n    function patch (el, oldnode, newnode) {\n        return (oldnode.type && oldnode.type === newnode.type ? morph : replace)(el, oldnode, newnode) \n    }\n\n    function getInstanceIndex(type, el) {\n        return seekIndex(type.instances, inst => (inst.el === el))\n    }\n\n    function makeView (type, attributes, children) {\n        const vnode = type.func(Object.assign({}, attributes, type.data), children); //common with morphInstance --> factor out.\n        const el = make(vnode);\n        type.instances = type.instances || [];\n        type.instances.push({el, vnode, attributes, children});\n        return el\n    }\n\n    function makeNode ({type, attributes={}, children=[]}, svg=false) {\n        if (type.func) return makeView(type, attributes, children)\n        svg = svg || (type === 'svg');\n        const el = svg ? document.createElementNS('http://www.w3.org/2000/svg', type) : document.createElement(type);\n        updateAttributes(el, {}, attributes);\n        children.forEach(chnode => el.appendChild(make(chnode, svg)));\n        attributes.oncreate && attributes.oncreate(el);\n        return el\n    }\n\n    function make (vnode, svg) {\n        return vnode.type ? makeNode(vnode, svg) : document.createTextNode(vnode)\n    }\n\n    function h (type, attributes, ...children) {\n        attributes = attributes || {};\n        children = [].concat(...[].concat(...children)).filter(c => (c !== false && c != null));\n        return (typeof type === 'function') ? type(attributes, children) : {type, attributes, children}\n    }\n\n    function define (func, data) {\n        return {func, data}\n    }\n\n    function mount (vnode, container) {\n        const el = make(vnode.func ? h(vnode) : vnode);\n        container.innerHTML = '';\n        container.appendChild(el);\n    }\n\n    function update (view, data) {\n        view.data = data;\n        view.instances = view.instances || []; //common pattern with makeInstance --> factor out\n        view.instances.forEach(inst => morphInstance(inst.el, view, inst.attributes, inst.children));\n    }\n\n    exports.h = h;\n    exports.patch = patch;\n    exports.make = make;\n    exports.mount = mount;\n    exports.define = define;\n    exports.update = update;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=zxdom.js.map\n"]}