{"version":3,"sources":["dist/zxdom.js"],"names":["global","factory","exports","module","define","amd","zxdom","this","seekIndex","list","fn","start","reduce","found","item","index","setAttribute","el","name","oldval","val","substr","removeAttribute","updateAttributes","oldattr","newattr","Object","keys","forEach","willRemove","oldvnode","prevent","type","attributes","children","func","inst","getInstanceIndex","instances","vnode","splice","map","chvnode","i","childNodes","onremove","replace","newvnode","newel","make","parentNode","insertBefore","replaceChild","getKey","node","attr","key","morphInstance","oldel","view","assign","data","patch","seekId","seekNode","sought","morphVNode","oldch","newch","parent","n","length","o","removeChild","appendChild","patchChildren","onupdate","oldnode","newnode","makeNode","svg","push","makeView","document","createElementNS","createElement","chnode","oncreate","h","createTextNode","concat","filter","c","mount","container","innerHTML","update","defineProperty","value"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.zxdom = {})));\n}(this, (function (exports) { 'use strict';\n\n    /*\n    TOODO: make it possible to use class instances as views, so you can call update(this.view, this)\n\n    TODO refactor functions that will use less property-names, and also make the code more readable and descriptive what is being done.\n\n    TODO refactor tests to be more descriptive of the api and less \"incrementally built up\"\n\n    TODO: Optimize: textnodes are always inserted, then the old ones removed. If they're the same string we could leave them alone\n\n    TODO: Optimize: If keyed nodes move down, we will instead move *up* every subsequent nodes one step. COuld be optimized\n    by just building a list of moves, and notice that a series of up-moves of one, could be replaced by a single\n    down move (maybe?)\n\n    TODO: transitions included as an optional (tree-shakeabke) module?\n\n    TODO: Example with forms and validation Something with forms and validations\n    */\n\n\n    function seekIndex(list, fn, start = 0) {\n        return list.reduce((found, item, index) => (index < start || found > -1 || !fn(item)) ? found : index, -1)\n    }\n\n\n    function setAttribute(el, name, oldval, val) {\n        if (name === 'key' || name === 'value' || name === 'checked' || name.substr(0,2) === 'on') {\n            el[name] = val;\n        } else if (val == null || val === false) {\n            el.removeAttribute(name);\n        } else if (oldval !== val) {\n            el.setAttribute(name, val);\n        }\n    }\n\n    function updateAttributes (el, oldattr, newattr) {\n        Object.keys(oldattr).forEach(name => {\n            if (newattr[name] == null) setAttribute(el, name);\n        });\n        Object.keys(newattr).forEach(name => {\n            setAttribute(el, name, oldattr[name], newattr[name]);\n        });\n    }\n\n    function willRemove(el, oldvnode) {\n        let prevent = false;\n        if (oldvnode.type) {\n            const {type, attributes, children} = oldvnode;\n            if (type.func) {\n                const inst = getInstanceIndex(type, el);\n                prevent = willRemove(el, type.instances[inst].vnode);\n                type.instances.splice(inst, 1);\n            } else {\n                children.map((chvnode, i) => willRemove(el.childNodes[i], chvnode));\n                if (attributes.onremove) { prevent = attributes.onremove(el); }\n            }    \n        }\n        return prevent\n    }\n\n    function remove(el, oldvnode) {\n        if (willRemove(el, oldvnode)) return false\n        el.parentNode && el.parentNode.removeChild(el);\n        return true\n    }\n\n    function replace (el, oldvnode, newvnode) {\n        const prevent = willRemove(el, oldvnode);\n        const newel = make(newvnode);\n        if (el.parentNode) {\n            if (prevent) el.parentNode.insertBefore(newel, el);\n            else el.parentNode.replaceChild(newel, el);\n        }\n        return newel\n    }\n\n    function getKey (node) {\n        const attr = node.attributes;\n        return (attr && attr.key) ? attr.key : null \n    }\n\n\n    function morphInstance (oldel, view, attributes, children) {\n        const vnode = view.func(Object.assign({}, attributes, view.data), children);\n        const inst = getInstanceIndex(view, oldel);\n        const oldvnode = view.instances[inst].vnode;\n        const el = (getKey(oldvnode) === getKey(vnode) ? patch : replace)(oldel, oldvnode, vnode);\n        view.instances.splice(inst, 1, {el, vnode, attributes, children});\n        return el\n    }\n\n\n    function seekId(node) {\n        return node.type ? (node.attributes.key || node.type) : node\n    }\n\n    function seekNode(list, node, start) {\n        const sought = seekId(node);\n        return seekIndex(list, item => (seekId(item) === sought), start)\n    }\n\n    function patchChildren(parent, oldch, newch) {\n        let n = 0;\n        while (n < oldch.length && n < newch.length) {\n            let o = seekNode(oldch, newch[n], n);\n            if (o < 0) {\n                parent.insertBefore(make(newch[n]), parent.childNodes[n]);\n                oldch.splice(n, 0, '');\n            } else {\n                if (o != n) {\n                    parent.insertBefore(parent.childNodes[o], parent.childNodes[n]);\n                    oldch.splice(n, 0, oldch.splice(o, 1)[0]);\n                }\n                patch(parent.childNodes[n], oldch[n], newch[n]);\n            }\n            n++;\n        }\n        while (n < oldch.length) {\n            const didRemove = remove(parent.childNodes[n], oldch[n]);\n            if (!didRemove) n++;\n            else oldch.splice(n, 1);\n        }\n        while (n < newch.length)  parent.appendChild(make(newch[n++]));\n    }\n\n\n    function morphVNode(el, oldattr, oldch, newattr, newch) {\n        updateAttributes(el, oldattr, newattr);\n        patchChildren(el, oldch, newch);\n        newattr.onupdate && newattr.onupdate(el);\n        return el\n    }\n\n\n    function morph (el, oldvnode, {type, attributes, children}) {\n        if (type.func) return morphInstance(el, type, attributes, children)\n        else return morphVNode(el, oldvnode.attributes, oldvnode.children, attributes, children)\n    }\n\n\n    function patch (el, oldnode, newnode) {\n        return (oldnode.type && oldnode.type === newnode.type ? morph : replace)(el, oldnode, newnode) \n    }\n\n    function getInstanceIndex(type, el) {\n        return seekIndex(type.instances, inst => (inst.el === el))\n    }\n\n    function makeView (type, attributes, children) {\n        const vnode = type.func(Object.assign({}, attributes, type.data), children); //common with morphInstance --> factor out.\n        const el = make(vnode);\n        type.instances = type.instances || [];\n        type.instances.push({el, vnode, attributes, children});\n        return el\n    }\n\n    function makeNode ({type, attributes={}, children=[]}, svg=false) {\n        if (type.func) return makeView(type, attributes, children)\n        svg = svg || (type === 'svg');\n        const el = svg ? document.createElementNS('http://www.w3.org/2000/svg', type) : document.createElement(type);\n        updateAttributes(el, {}, attributes);\n        children.forEach(chnode => el.appendChild(make(chnode, svg)));\n        attributes.oncreate && attributes.oncreate(el);\n        return el\n    }\n\n    function make (vnode, svg) {\n        return vnode.func ? make(h(vnode)) : vnode.type ? makeNode(vnode, svg) : document.createTextNode(vnode)\n    }\n\n    function h (type, attributes, ...children) {\n        attributes = attributes || {};\n        children = [].concat(...[].concat(...children)).filter(c => (c !== false && c != null));\n        return (typeof type === 'function') ? type(attributes, children) : {type, attributes, children}\n    }\n\n    function define (func, data) {\n        return {func, data}\n    }\n\n    function mount (vnode, container) {\n        const el = make(vnode);\n        container.innerHTML = '';\n        container.appendChild(el);\n    }\n\n    function update (view, data) {\n        view.data = data;\n        view.instances = view.instances || []; //common pattern with makeInstance --> factor out\n        view.instances.forEach(inst => morphInstance(inst.el, view, inst.attributes, inst.children));\n    }\n\n    exports.h = h;\n    exports.patch = patch;\n    exports.make = make;\n    exports.mount = mount;\n    exports.define = define;\n    exports.update = update;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=zxdom.js.map\n"]}